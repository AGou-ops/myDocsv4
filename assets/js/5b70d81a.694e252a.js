"use strict";(self.webpackChunkmy_docsv_4=self.webpackChunkmy_docsv_4||[]).push([[3413],{3905:(e,n,t)=>{t.d(n,{Zo:()=>f,kt:()=>u});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),d=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},f=function(e){var n=d(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,f=o(e,["components","mdxType","originalType","parentName"]),m=d(t),u=a,g=m["".concat(s,".").concat(u)]||m[u]||p[u]||i;return t?r.createElement(g,l(l({ref:n},f),{},{components:t})):r.createElement(g,l({ref:n},f))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var d=2;d<i;d++)l[d]=t[d];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},98999:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=t(87462),a=(t(67294),t(3905));const i={},l="Golang \u6587\u4ef6\u64cd\u4f5c",o={unversionedId:"ProgramLang/Golang/Golang File Operate",id:"ProgramLang/Golang/Golang File Operate",title:"Golang \u6587\u4ef6\u64cd\u4f5c",description:"\u90e8\u5206\u539f\u6587\u94fe\u63a5\uff1ahttps://www.devdungeon.com/content/working-files-go#everythingisa_file",source:"@site/docs/ProgramLang/Golang/Golang File Operate.md",sourceDirName:"ProgramLang/Golang",slug:"/ProgramLang/Golang/Golang File Operate",permalink:"/docs/ProgramLang/Golang/Golang File Operate",draft:!1,editUrl:"https://github.com/AGou-ops/myDocsv4/edit/main/docs/ProgramLang/Golang/Golang File Operate.md",tags:[],version:"current",frontMatter:{},sidebar:"programLang",previous:{title:"Golang \u9519\u8bef\u53ca\u9519\u8bef\u5904\u7406",permalink:"/docs/ProgramLang/Golang/Golang Errors - handler"},next:{title:"Golang \u51fd\u6570",permalink:"/docs/ProgramLang/Golang/Golang Function"}},s={},d=[{value:"Everything is a File",id:"everything-is-a-file",level:2},{value:"Create Empty File",id:"create-empty-file",level:2},{value:"\u6587\u4ef6\u5939\u64cd\u4f5c",id:"\u6587\u4ef6\u5939\u64cd\u4f5c",level:2},{value:"Truncate a File",id:"truncate-a-file",level:2},{value:"Get File Info",id:"get-file-info",level:2},{value:"Rename and Move a File",id:"rename-and-move-a-file",level:2},{value:"Delete a File",id:"delete-a-file",level:2},{value:"Open and Close Files",id:"open-and-close-files",level:2},{value:"Check if File Exists",id:"check-if-file-exists",level:2},{value:"Check Read and Write Permissions",id:"check-read-and-write-permissions",level:2},{value:"Change Permissions, Ownership, and Timestamps",id:"change-permissions-ownership-and-timestamps",level:2},{value:"Hard Links and Symlinks",id:"hard-links-and-symlinks",level:2},{value:"Copy a File",id:"copy-a-file",level:2},{value:"Seek Positions in File",id:"seek-positions-in-file",level:2},{value:"Write Bytes to a File",id:"write-bytes-to-a-file",level:2},{value:"Quick Write to File",id:"quick-write-to-file",level:2},{value:"Use Buffered Writer",id:"use-buffered-writer",level:2},{value:"Read up to n Bytes from File",id:"read-up-to-n-bytes-from-file",level:2},{value:"Read Exactly n Bytes",id:"read-exactly-n-bytes",level:2},{value:"Read At Least n Bytes",id:"read-at-least-n-bytes",level:2},{value:"Read All Bytes of File",id:"read-all-bytes-of-file",level:2},{value:"Quick Read Whole File to Memory",id:"quick-read-whole-file-to-memory",level:2},{value:"Use Buffered Reader",id:"use-buffered-reader",level:2},{value:"Read with a Scanner",id:"read-with-a-scanner",level:2},{value:"Archive(Zip) Files",id:"archivezip-files",level:2},{value:"Extract(Unzip) Archived Files",id:"extractunzip-archived-files",level:2},{value:"Compress a File",id:"compress-a-file",level:2},{value:"Uncompress a File",id:"uncompress-a-file",level:2},{value:"Temporary Files and Directories",id:"temporary-files-and-directories",level:2},{value:"Downloading a File Over HTTP",id:"downloading-a-file-over-http",level:2},{value:"Hashing and Checksums",id:"hashing-and-checksums",level:2},{value:"\u9644\u5f55\uff1aGolang \u6587\u4ef6\u76f8\u5173\u51fd\u6570",id:"\u9644\u5f55golang-\u6587\u4ef6\u76f8\u5173\u51fd\u6570",level:2},{value:"Basic Operations",id:"basic-operations",level:3},{value:"file open flag",id:"file-open-flag",level:3},{value:"Hard Link &amp; Symbol Link",id:"hard-link--symbol-link",level:3},{value:"Read and Write",id:"read-and-write",level:3},{value:"Work with direct\xadories",id:"work-with-directories",level:3},{value:"Shortcuts",id:"shortcuts",level:3},{value:"Temporary files and direct\xadories",id:"temporary-files-and-directories-1",level:3},{value:"References",id:"references",level:3},{value:"\u53c2\u8003\u94fe\u63a5",id:"\u53c2\u8003\u94fe\u63a5",level:2}],f={toc:d};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"golang-\u6587\u4ef6\u64cd\u4f5c"},"Golang \u6587\u4ef6\u64cd\u4f5c"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u90e8\u5206\u539f\u6587\u94fe\u63a5\uff1a",(0,a.kt)("a",{parentName:"p",href:"https://www.devdungeon.com/content/working-files-go#everything_is_a_file"},"https://www.devdungeon.com/content/working-files-go#everything_is_a_file"))),(0,a.kt)("h2",{id:"everything-is-a-file"},"Everything is a File"),(0,a.kt)("p",null,"One of the fundamental aspects of UNIX is that everything is a file. We don't necessarily know what the file descriptor maps to, that is abstracted by the operating system's device drivers. The operating system provides us an interface to the device in the form of a file."),(0,a.kt)("p",null,"The reader and writer interfaces in Go are similar abstractions. We simply read and write bytes, without the need to understand where or how the reader gets its data or where the writer is sending the data. Look in ",(0,a.kt)("strong",{parentName:"p"},"/dev")," to find available devices. Some will require elevated privileges to access."),(0,a.kt)("h2",{id:"create-empty-file"},"Create Empty File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "os"\n)\n\nvar (\n    newFile *os.File\n    err     error\n)\n\nfunc main() {\n    newFile, err = os.Create("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Println(newFile)\n    newFile.Close()\n}\n')),(0,a.kt)("h2",{id:"\u6587\u4ef6\u5939\u64cd\u4f5c"},"\u6587\u4ef6\u5939\u64cd\u4f5c"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// \u5feb\u901f\u5f00\u59cb\npath := "test/"\n// \u5ffd\u7565\u8b66\u544a\u5185\u5bb9\n_ = os.Mkdir(path, os.ModePerm)\n\n// \u5f53\u6587\u4ef6\u5939\u4e0d\u5b58\u5728\u65f6\u521b\u5efa\u6587\u4ef6\u5939\npath := "test/"\nif _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {\n    err := os.Mkdir(path, os.ModePerm)\n    if err != nil {\n        log.Println(err)\n    }\n}\n\n// \u9012\u5f52\u521b\u5efa\u6587\u4ef6\u5939\npath := "test/test1/test2/test3"\nerr := os.MkdirAll(path, os.ModePerm)\nif err != nil {\n    log.Println(err)\n}\n\n// rename \u6587\u4ef6\u5939\nerr := os.Rename("test/", "test2/")\n\n// delete \u6587\u4ef6\u5939\uff0c\u9012\u5f52\u5220\u9664\nerr := os.RemoveAll("filepath")\n\n// \u83b7\u53d6\u5f53\u524d\u76ee\u5f55\u6240\u6709\u6587\u4ef6\u4ee5\u53ca\u6587\u4ef6\u5939\nfile, err := os.Open(".")\nif err != nil {\n    log.Fatal(file)\n}\ndefer file.Close()\n//  \u8bfb\u53d6\u76ee\u5f55\u4e0b\u7684\u5b50\u6587\u4ef6(\u6709\u53ef\u80fd\u662f\u4e00\u4e2a\u6587\u4ef6\uff0c\u6709\u53ef\u80fd\u662f\u4e00\u4e2a\u5b50\u76ee\u5f55)\n// fmt.Println(file.Readdir(10))\n// fmt.Println(file.Readdirnames(10))\n// fmt.Println(file.Readdirnames(10))\n// fmt.Println(file.Readdirnames(-1))\nfiles, err := file.Readdir(-1)\nfor _, file := range files {\n    fmt.Println(file.IsDir(), file.Name(), file.Size(), file.ModTime(), file.Mode())\n}\n\n')),(0,a.kt)("h2",{id:"truncate-a-file"},"Truncate a File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "os"\n)\n\nfunc main() {\n    // Truncate a file to 100 bytes. If file\n    // is less than 100 bytes the original contents will remain\n    // at the beginning, and the rest of the space is\n    // filled will null bytes. If it is over 100 bytes,\n    // Everything past 100 bytes will be lost. Either way\n    // we will end up with exactly 100 bytes.\n    // Pass in 0 to truncate to a completely empty file\n\n    err := os.Truncate("test.txt", 100)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"get-file-info"},"Get File Info"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "log"\n    "os"\n)\n\nvar (\n    fileInfo os.FileInfo\n    err      error\n)\n\nfunc main() {\n    // Stat returns file info. It will return\n    // an error if there is no file.\n    fileInfo, err = os.Stat("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println("File name:", fileInfo.Name())\n    fmt.Println("Size in bytes:", fileInfo.Size())\n    fmt.Println("Permissions:", fileInfo.Mode())\n    fmt.Println("Last modified:", fileInfo.ModTime())\n    fmt.Println("Is Directory: ", fileInfo.IsDir())\n    fmt.Printf("System interface type: %T\\n", fileInfo.Sys())\n    fmt.Printf("System info: %+v\\n\\n", fileInfo.Sys())\n}\n')),(0,a.kt)("h2",{id:"rename-and-move-a-file"},"Rename and Move a File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "os"\n)\n\nfunc main() {\n    originalPath := "test.txt"\n    newPath := "test2.txt"\n    err := os.Rename(originalPath, newPath)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"delete-a-file"},"Delete a File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "os"\n)\n\nfunc main() {\n    err := os.Remove("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"open-and-close-files"},"Open and Close Files"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "os"\n)\n\nfunc main() {\n    // Simple read only open. We will cover actually reading\n    // and writing to files in examples further down the page\n    file, err := os.Open("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    file.Close()\n\n    // OpenFile with more options. Last param is the permission mode\n    // Second param is the attributes when opening\n    file, err = os.OpenFile("test.txt", os.O_APPEND, 0666)\n    if err != nil {\n        log.Fatal(err)\n    }\n    file.Close()\n\n    // Use these attributes individually or combined\n    // with an OR for second arg of OpenFile()\n    // e.g. os.O_CREATE|os.O_APPEND\n    // or os.O_CREATE|os.O_TRUNC|os.O_WRONLY\n\n    // os.O_RDONLY // Read only\n    // os.O_WRONLY // Write only\n    // os.O_RDWR // Read and write\n    // os.O_APPEND // Append to end of file\n    // os.O_CREATE // Create is none exist\n    // os.O_TRUNC // Truncate file when opening\n}\n')),(0,a.kt)("h2",{id:"check-if-file-exists"},"Check if File Exists"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "os"\n)\n\nvar (\n    fileInfo *os.FileInfo\n    err      error\n)\n\nfunc main() {\n    // Stat returns file info. It will return\n    // an error if there is no file.\n    fileInfo, err := os.Stat("test.txt")\n    if err != nil {\n        if os.IsNotExist(err) {\n            log.Fatal("File does not exist.")\n        }\n    }\n    log.Println("File does exist. File information:")\n    log.Println(fileInfo)\n}\n')),(0,a.kt)("h2",{id:"check-read-and-write-permissions"},"Check Read and Write Permissions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "os"\n)\n\nfunc main() {\n    // Test write permissions. It is possible the file\n    // does not exist and that will return a different\n    // error that can be checked with os.IsNotExist(err)\n    file, err := os.OpenFile("test.txt", os.O_WRONLY, 0666)\n    if err != nil {\n        if os.IsPermission(err) {\n            log.Println("Error: Write permission denied.")\n        }\n    }\n    file.Close()\n\n    // Test read permissions\n    file, err = os.OpenFile("test.txt", os.O_RDONLY, 0666)\n    if err != nil {\n        if os.IsPermission(err) {\n            log.Println("Error: Read permission denied.")\n        }\n    }\n    file.Close()\n}\n')),(0,a.kt)("h2",{id:"change-permissions-ownership-and-timestamps"},"Change Permissions, Ownership, and Timestamps"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "os"\n    "time"\n)\n\nfunc main() {\n    // Change perrmissions using Linux style\n    err := os.Chmod("test.txt", 0777)\n    if err != nil {\n        log.Println(err)\n    }\n\n    // Change ownership\n    err = os.Chown("test.txt", os.Getuid(), os.Getgid())\n    if err != nil {\n        log.Println(err)\n    }\n\n    // Change timestamps\n    twoDaysFromNow := time.Now().Add(48 * time.Hour)\n    lastAccessTime := twoDaysFromNow\n    lastModifyTime := twoDaysFromNow\n    err = os.Chtimes("test.txt", lastAccessTime, lastModifyTime)\n    if err != nil {\n        log.Println(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"hard-links-and-symlinks"},"Hard Links and Symlinks"),(0,a.kt)("p",null,"A typical file is just a pointer to a place on the hard disk called an inode. A hard link creates a new pointer to the same place. A file will only be deleted from disk after all links are removed. Hard links only work on the same file system. A hard link is what you might consider a 'normal' link."),(0,a.kt)("p",null,"A symbolic link, or soft link, is a little different, it does not point directly to a place on the disk. Symlinks only reference other files by name. They can point to files on different filesystems. Not all systems support symlinks."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "log"\n    "fmt"\n)\n\nfunc main() {\n    // Create a hard link\n    // You will have two file names that point to the same contents\n    // Changing the contents of one will change the other\n    // Deleting/renaming one will not affect the other\n    err := os.Link("original.txt", "original_also.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println("creating sym")\n    // Create a symlink\n    err = os.Symlink("original.txt", "original_sym.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Lstat will return file info, but if it is actually\n    // a symlink, it will return info about the symlink.\n    // It will not follow the link and give information\n    // about the real file\n    // Symlinks do not work in Windows\n    fileInfo, err := os.Lstat("original_sym.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf("Link info: %+v", fileInfo)\n\n    // Change ownership of a symlink only \n    // and not the file it points to\n    err = os.Lchown("original_sym.txt", os.Getuid(), os.Getgid())\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"copy-a-file"},"Copy a File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "log"\n    "io"\n)\n\n// Copy a file\nfunc main() {\n    // Open original file\n    originalFile, err := os.Open("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer originalFile.Close()\n\n    // Create new file\n    newFile, err := os.Create("test_copy.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer newFile.Close()\n\n    // Copy the bytes to destination from source\n    bytesWritten, err := io.Copy(newFile, originalFile)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Copied %d bytes.", bytesWritten)\n    \n    // Copy the bytes to destination from source -- way 2, use ioutil package\n    input, err := ioutil.ReadFile(sourceFile)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    err = ioutil.WriteFile(destinationFile, input, 0644)\n    if err != nil {\n        fmt.Println("Error creating", destinationFile)\n        fmt.Println(err)\n        return\n    }\n    \n    // Commit the file contents\n    // Flushes memory to disk\n    err = newFile.Sync()\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"seek-positions-in-file"},"Seek Positions in File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "fmt"\n    "log"\n)\n\nfunc main() {\n    file, _ := os.Open("test.txt")\n    defer file.Close()\n\n    // Offset is how many bytes to move\n    // Offset can be positive or negative\n    var offset int64 = 5\n\n    // Whence is the point of reference for offset\n    // 0 = Beginning of file\n    // 1 = Current position\n    // 2 = End of file\n    var whence int = 0\n    newPosition, err := file.Seek(offset, whence)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println("Just moved to 5:", newPosition)\n\n    // Go back 2 bytes from current position\n    newPosition, err = file.Seek(-2, 1)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println("Just moved back two:", newPosition)\n\n    // Find the current position by getting the\n    // return value from Seek after moving 0 bytes\n    currentPosition, err := file.Seek(0, 1)\n    fmt.Println("Current position:", currentPosition)\n\n    // Go to beginning of file\n    newPosition, err = file.Seek(0, 0)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println("Position after seeking 0,0:", newPosition)\n}\n')),(0,a.kt)("h2",{id:"write-bytes-to-a-file"},"Write Bytes to a File"),(0,a.kt)("p",null,"You can write using just the os package which is needed already to open the file. Since all Go executables are statically linked binaries, every package you import increases the size of your executable. Other packages like ",(0,a.kt)("strong",{parentName:"p"},"io"),", ",(0,a.kt)("strong",{parentName:"p"},"ioutil"),", and ",(0,a.kt)("strong",{parentName:"p"},"bufio")," provide some more help, but they are not necessary."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "log"\n)\n\nfunc main() {\n    // Open a new file for writing only\n    file, err := os.OpenFile(\n        "test.txt",\n        os.O_WRONLY|os.O_TRUNC|os.O_CREATE,\n        0666,\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n\n    // Write bytes to file\n    byteSlice := []byte("Bytes!\\n")\n    bytesWritten, err := file.Write(byteSlice)\n    // append string to file\n    appendWritten, _ := newFile.WriteString("something here.\\n")\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Wrote %d bytes.\\n", bytesWritten)\n    log.Printf("Wrote %d bytes.\\n", appendWritten)\n}\n')),(0,a.kt)("h2",{id:"quick-write-to-file"},"Quick Write to File"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"ioutil")," package has a useful function called ",(0,a.kt)("strong",{parentName:"p"},"WriteFile()")," that will handle creating/opening, writing a slice of bytes, and closing. It is useful if you just need a quick way to dump a slice of bytes to a file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "io/ioutil"\n    "log"\n)\n\nfunc main() {\n    err := ioutil.WriteFile("test.txt", []byte("Hi\\n"), 0666)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"use-buffered-writer"},"Use Buffered Writer"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"bufio")," package lets you create a buffered writer so you can work with a buffer in memory before writing it to disk. This is useful if you need to do a lot manipulation on the data before writing it to disk to save time from disk IO. It is also useful if you only write one byte at a time and want to store a large number in memory before dumping it to file at once, otherwise you would be performing disk IO for every byte. That puts wear and tear on your disk as well as slows down the process."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "os"\n    "bufio"\n)\n\nfunc main() {\n    // Open file for writing\n    file, err := os.OpenFile("test.txt", os.O_WRONLY, 0666)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n\n    // Create a buffered writer from the file\n    bufferedWriter := bufio.NewWriter(file)\n\n    // Write bytes to buffer\n    bytesWritten, err := bufferedWriter.Write(\n        []byte{65, 66, 67},\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Bytes written: %d\\n", bytesWritten)\n\n    // Write string to buffer\n    // Also available are WriteRune() and WriteByte()   \n    bytesWritten, err = bufferedWriter.WriteString(\n        "Buffered string\\n",\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Bytes written: %d\\n", bytesWritten)\n\n    // Check how much is stored in buffer waiting\n    unflushedBufferSize := bufferedWriter.Buffered()\n    log.Printf("Bytes buffered: %d\\n", unflushedBufferSize)\n\n    // See how much buffer is available\n    bytesAvailable := bufferedWriter.Available()\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Available buffer: %d\\n", bytesAvailable)\n\n    // Write memory buffer to disk\n    bufferedWriter.Flush()\n\n    // Revert any changes done to buffer that have\n    // not yet been written to file with Flush()\n    // We just flushed, so there are no changes to revert\n    // The writer that you pass as an argument\n    // is where the buffer will output to, if you want\n    // to change to a new writer\n    bufferedWriter.Reset(bufferedWriter) \n\n    // See how much buffer is available\n    bytesAvailable = bufferedWriter.Available()\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Available buffer: %d\\n", bytesAvailable)\n\n    // Resize buffer. The first argument is a writer\n    // where the buffer should output to. In this case\n    // we are using the same buffer. If we chose a number\n    // that was smaller than the existing buffer, like 10\n    // we would not get back a buffer of size 10, we will\n    // get back a buffer the size of the original since\n    // it was already large enough (default 4096)\n    bufferedWriter = bufio.NewWriterSize(\n        bufferedWriter,\n        8000,\n    )\n\n    // Check available buffer size after resizing\n    bytesAvailable = bufferedWriter.Available()\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Available buffer: %d\\n", bytesAvailable)\n}\n')),(0,a.kt)("h2",{id:"read-up-to-n-bytes-from-file"},"Read up to n Bytes from File"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"os.File")," type provides a couple basic functions. The ",(0,a.kt)("strong",{parentName:"p"},"io"),", ",(0,a.kt)("strong",{parentName:"p"},"ioutil"),", and ",(0,a.kt)("strong",{parentName:"p"},"bufio")," packages provided additional functions for working with files."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "log"\n)\n\nfunc main() {\n    // Open file for reading\n    file, err := os.Open("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n\n    // Read up to len(b) bytes from the File\n    // Zero bytes written means end of file\n    // End of file returns error type io.EOF\n    byteSlice := make([]byte, 16)\n    bytesRead, err := file.Read(byteSlice)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Number of bytes read: %d\\n", bytesRead)\n    log.Printf("Data read: %s\\n", byteSlice)\n}\n')),(0,a.kt)("h2",{id:"read-exactly-n-bytes"},"Read Exactly n Bytes"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "log"\n    "io"\n)\n\nfunc main() {\n    // Open file for reading\n    file, err := os.Open("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // The file.Read() function will happily read a tiny file in to a large\n    // byte slice, but io.ReadFull() will return an\n    // error if the file is smaller than the byte slice.\n    byteSlice := make([]byte, 2)\n    numBytesRead, err := io.ReadFull(file, byteSlice)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Number of bytes read: %d\\n", numBytesRead)\n    log.Printf("Data read: %s\\n", byteSlice)\n}\n')),(0,a.kt)("h2",{id:"read-at-least-n-bytes"},"Read At Least n Bytes"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "log"\n    "io"\n)\n\nfunc main() {\n    // Open file for reading\n    file, err := os.Open("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    byteSlice := make([]byte, 512)\n    minBytes := 8\n    // io.ReadAtLeast() will return an error if it cannot\n    // find at least minBytes to read. It will read as\n    // many bytes as byteSlice can hold. \n    numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf("Number of bytes read: %d\\n", numBytesRead)\n    log.Printf("Data read: %s\\n", byteSlice)\n}\n')),(0,a.kt)("h2",{id:"read-all-bytes-of-file"},"Read All Bytes of File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "log"\n    "fmt"\n    "io/ioutil"\n)\n\nfunc main() {\n    // Open file for reading\n    file, err := os.Open("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // os.File.Read(), io.ReadFull(), and\n    // io.ReadAtLeast() all work with a fixed\n    // byte slice that you make before you read\n\n    // ioutil.ReadAll() will read every byte\n    // from the reader (in this case a file),\n    // and return a slice of unknown slice\n    data, err := ioutil.ReadAll(file)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf("Data as hex: %x\\n", data)\n    fmt.Printf("Data as string: %s\\n", data)\n    fmt.Println("Number of bytes read:", len(data))\n}\n')),(0,a.kt)("h2",{id:"quick-read-whole-file-to-memory"},"Quick Read Whole File to Memory"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "log"\n    "io/ioutil"\n)\n\nfunc main() {\n    // Read file to byte slice\n    data, err := ioutil.ReadFile("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Printf("Data read: %s\\n", data)\n}\n')),(0,a.kt)("h2",{id:"use-buffered-reader"},"Use Buffered Reader"),(0,a.kt)("p",null,"Creating a buffered reader will store a memory buffer with some of the contents. A buffered reader also provides some more functions that are not available on the ",(0,a.kt)("strong",{parentName:"p"},"os.File")," type or the ",(0,a.kt)("strong",{parentName:"p"},"io.Reader"),". Default buffer size is 4096 and minimum size is 16."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "log"\n    "bufio"\n    "fmt"\n)\n\nfunc main() {\n    // Open file and create a buffered reader on top\n    file, err := os.Open("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    bufferedReader := bufio.NewReader(file)\n\n    // Get bytes without advancing pointer\n    byteSlice := make([]byte, 5)\n    byteSlice, err = bufferedReader.Peek(5)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf("Peeked at 5 bytes: %s\\n", byteSlice)\n\n    // Read and advance pointer\n    numBytesRead, err := bufferedReader.Read(byteSlice)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf("Read %d bytes: %s\\n", numBytesRead, byteSlice)\n\n    // Ready 1 byte. Error if no byte to read\n    myByte, err := bufferedReader.ReadByte()\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf("Read 1 byte: %c\\n", myByte)     \n\n    // Read up to and including delimiter\n    // Returns byte slice\n    dataBytes, err := bufferedReader.ReadBytes(\'\\n\') \n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf("Read bytes: %s\\n", dataBytes)           \n\n    // Read up to and including delimiter\n    // Returns string   \n    dataString, err := bufferedReader.ReadString(\'\\n\')\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf("Read string: %s\\n", dataString)     \n\n    // This example reads a few lines so test.txt\n    // should have a few lines of text to work correct\n}\n')),(0,a.kt)("h2",{id:"read-with-a-scanner"},"Read with a Scanner"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Scanner")," is part of the ",(0,a.kt)("strong",{parentName:"p"},"bufio")," package. It is useful for stepping through files at specific delimiters. Commonly, the newline character is used as the delimiter to break up a file by lines. In a CSV file, commas would be the delimiter. The ",(0,a.kt)("strong",{parentName:"p"},"os.File")," can be wrapped in a ",(0,a.kt)("strong",{parentName:"p"},"bufio.Scanner")," just like a buffered reader. We call ",(0,a.kt)("strong",{parentName:"p"},"Scan()")," to read up to the next delimiter, and then use ",(0,a.kt)("strong",{parentName:"p"},"Text()")," or ",(0,a.kt)("strong",{parentName:"p"},"Bytes()")," to get the data that was read."),(0,a.kt)("p",null,"The delimiter is not just a simple byte or character. There is actually a special function you have to implement that will determine where the next delimiter is, how far forward to advance the pointer, and what data to return. If no custom ",(0,a.kt)("strong",{parentName:"p"},"SplitFunc")," is provided, it defaults to ",(0,a.kt)("strong",{parentName:"p"},"ScanLines")," which will split at every newline character. Other split functions included in ",(0,a.kt)("strong",{parentName:"p"},"bufio")," are ",(0,a.kt)("strong",{parentName:"p"},"ScanRunes"),", and ",(0,a.kt)("strong",{parentName:"p"},"ScanWords"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// To define your own split function, match this fingerprint\ntype SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)\n\n// Returning (0, nil, nil) will tell the scanner\n// to scan again, but with a bigger buffer because\n// it wasn't enough data to reach the delimiter\n")),(0,a.kt)("p",null,"In the next example, a ",(0,a.kt)("strong",{parentName:"p"},"bufio.Scanner")," is created from the file, and then we scan read the file word by word."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "os"\n    "log"\n    "fmt"\n    "bufio"\n)\n\nfunc main() {\n    // Open file and create scanner on top of it\n    file, err := os.Open("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    scanner := bufio.NewScanner(file)\n\n    // Default scanner is bufio.ScanLines. Lets use ScanWords.\n    // Could also use a custom function of SplitFunc type\n    scanner.Split(bufio.ScanWords)\n\n    // Scan for next token. \n    success := scanner.Scan() \n    if success == false {\n        // False on error or EOF. Check error\n        err = scanner.Err()\n        if err == nil {\n            log.Println("Scan completed and reached EOF")\n        } else {\n            log.Fatal(err)\n        }\n    }\n\n    // Get data from scan with Bytes() or Text()\n    fmt.Println("First word found:", scanner.Text())\n\n    // Call scanner.Scan() again to find next token\n}\n')),(0,a.kt)("h2",{id:"archivezip-files"},"Archive(Zip) Files"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// This example uses zip but standard library\n// also supports tar archives\npackage main\n\nimport (\n    "archive/zip"\n    "log"\n    "os"\n)\n\nfunc main() {\n    // Create a file to write the archive buffer to\n    // Could also use an in memory buffer.\n    outFile, err := os.Create("test.zip")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer outFile.Close()\n\n    // Create a zip writer on top of the file writer\n    zipWriter := zip.NewWriter(outFile)\n\n\n    // Add files to archive\n    // We use some hard coded data to demonstrate,\n    // but you could iterate through all the files\n    // in a directory and pass the name and contents\n    // of each file, or you can take data from your\n    // program and write it write in to the archive\n    // without \n    var filesToArchive = []struct {\n        Name, Body string\n    } {\n        {"test.txt", "String contents of file"},\n        {"test2.txt", "\\x61\\x62\\x63\\n"},\n    }\n\n    // Create and write files to the archive, which in turn\n    // are getting written to the underlying writer to the\n    // .zip file we created at the beginning\n    for _, file := range filesToArchive {\n            fileWriter, err := zipWriter.Create(file.Name)\n            if err != nil {\n                    log.Fatal(err)\n            }\n            _, err = fileWriter.Write([]byte(file.Body))\n            if err != nil {\n                    log.Fatal(err)\n            }\n    }\n\n    // Clean up\n    err = zipWriter.Close()\n    if err != nil {\n            log.Fatal(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"extractunzip-archived-files"},"Extract(Unzip) Archived Files"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// This example uses zip but standard library\n// also supports tar archives\npackage main\n\nimport (\n    "archive/zip"\n    "log"\n    "io"\n    "os"\n    "path/filepath"\n)\n\nfunc main() {\n    // Create a reader out of the zip archive\n    zipReader, err := zip.OpenReader("test.zip")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer zipReader.Close()\n\n    // Iterate through each file/dir found in\n    for _, file := range zipReader.Reader.File {\n        // Open the file inside the zip archive\n        // like a normal file\n        zippedFile, err := file.Open()\n        if err != nil {\n            log.Fatal(err)\n        }\n        defer zippedFile.Close()\n        \n        // Specify what the extracted file name should be.\n        // You can specify a full path or a prefix\n        // to move it to a different directory. \n        // In this case, we will extract the file from\n        // the zip to a file of the same name.\n        targetDir := "./"\n        extractedFilePath := filepath.Join(\n            targetDir,\n            file.Name,\n        )\n\n        // Extract the item (or create directory)\n        if file.FileInfo().IsDir() {\n            // Create directories to recreate directory\n            // structure inside the zip archive. Also\n            // preserves permissions\n            log.Println("Creating directory:", extractedFilePath)\n            os.MkdirAll(extractedFilePath, file.Mode())\n        } else {\n            // Extract regular file since not a directory\n            log.Println("Extracting file:", file.Name)\n\n            // Open an output file for writing\n            outputFile, err := os.OpenFile(\n                extractedFilePath,\n                os.O_WRONLY|os.O_CREATE|os.O_TRUNC,\n                file.Mode(),\n            )\n            if err != nil {\n                log.Fatal(err)\n            }\n            defer outputFile.Close()\n\n            // "Extract" the file by copying zipped file\n            // contents to the output file\n            _, err = io.Copy(outputFile, zippedFile)\n            if err != nil {\n                log.Fatal(err)\n            }\n        }\n    }\n}\n')),(0,a.kt)("h2",{id:"compress-a-file"},"Compress a File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// This example uses gzip but standard library also\n// supports zlib, bz2, flate, and lzw\npackage main\n\nimport (\n    "os"\n    "compress/gzip"\n    "log"\n)\n\nfunc main() {\n    // Create .gz file to write to\n    outputFile, err := os.Create("test.txt.gz")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create a gzip writer on top of file writer\n    gzipWriter := gzip.NewWriter(outputFile)\n    defer gzipWriter.Close()\n\n    // When we write to the gzip writer\n    // it will in turn compress the contents\n    // and then write it to the underlying\n    // file writer as well\n    // We don\'t have to worry about how all\n    // the compression works since we just\n    // use it as a simple writer interface\n    // that we send bytes to\n    _, err = gzipWriter.Write([]byte("Gophers rule!\\n"))\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Println("Compressed data written to file.") \n}\n')),(0,a.kt)("h2",{id:"uncompress-a-file"},"Uncompress a File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// This example uses gzip but standard library also\n// supports zlib, bz2, flate, and lzw\npackage main\n\nimport (\n    "compress/gzip"\n    "log"\n    "io"\n    "os"\n)\n\nfunc main() {\n    // Open gzip file that we want to uncompress\n    // The file is a reader, but we could use any\n    // data source. It is common for web servers\n    // to return gzipped contents to save bandwidth\n    // and in that case the data is not in a file\n    // on the file system but is in a memory buffer\n    gzipFile, err := os.Open("test.txt.gz")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create a gzip reader on top of the file reader\n    // Again, it could be any type reader though\n    gzipReader, err := gzip.NewReader(gzipFile)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer gzipReader.Close()\n\n    // Uncompress to a writer. We\'ll use a file writer\n    outfileWriter, err := os.Create("unzipped.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer outfileWriter.Close()\n\n    // Copy contents of gzipped file to output file\n    _, err = io.Copy(outfileWriter, gzipReader)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"temporary-files-and-directories"},"Temporary Files and Directories"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"ioutil")," package provides two functions: TempDir() and TempFile(). It is the callers responsibility to delete the temporary items when done. The only benefit these functions provide is that you can pass it an empty string for the directory, and it will automatically create the item in the system's default temporary folder (/tmp on Linux). Since ",(0,a.kt)("strong",{parentName:"p"},"os.TempDir()")," function that will return the defauly system temporary directory."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n     "os"\n     "io/ioutil"\n     "log"\n     "fmt"\n)\n\nfunc main() {\n     // Create a temp dir in the system default temp folder\n     tempDirPath, err := ioutil.TempDir("", "myTempDir")\n     if err != nil {\n          log.Fatal(err)\n     }\n     fmt.Println("Temp dir created:", tempDirPath)\n\n     // Create a file in new temp directory\n     tempFile, err := ioutil.TempFile(tempDirPath, "myTempFile.txt")\n     if err != nil {\n          log.Fatal(err)\n     }\n     fmt.Println("Temp file created:", tempFile.Name())\n     \n     // ... do something with temp file/dir ...\n\n     // Close file\n     err = tempFile.Close()\n     if err != nil {\n        log.Fatal(err)\n    }\n\n    // Delete the resources we created\n     err = os.Remove(tempFile.Name())\n     if err != nil {\n        log.Fatal(err)\n    }\n     err = os.Remove(tempDirPath)\n     if err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,a.kt)("h2",{id:"downloading-a-file-over-http"},"Downloading a File Over HTTP"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n     "os"\n     "io"\n     "log"\n     "net/http"\n)\n\nfunc main() {\n     // Create output file\n     newFile, err := os.Create("devdungeon.html")\n     if err != nil {\n          log.Fatal(err)\n     }\n     defer newFile.Close()\n\n     // HTTP GET request devdungeon.com \n     url := "http://www.devdungeon.com/archive"\n     response, err := http.Get(url)\n     defer response.Body.Close()\n\n     // Write bytes from HTTP response to file.\n     // response.Body satisfies the reader interface.\n     // newFile satisfies the writer interface.\n     // That allows us to use io.Copy which accepts\n     // any type that implements reader and writer interface\n     numBytesWritten, err := io.Copy(newFile, response.Body)\n     if err != nil {\n          log.Fatal(err)\n     }\n     log.Printf("Downloaded %d byte file.\\n", numBytesWritten)\n}\n')),(0,a.kt)("h2",{id:"hashing-and-checksums"},"Hashing and Checksums"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "crypto/md5"\n    "crypto/sha1"\n    "crypto/sha256"\n    "crypto/sha512"\n    "log"\n    "fmt"\n    "io/ioutil"\n)\n\nfunc main() {\n    // Get bytes from file\n    data, err := ioutil.ReadFile("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Hash the file and output results\n    fmt.Printf("Md5: %x\\n\\n", md5.Sum(data))\n    fmt.Printf("Sha1: %x\\n\\n", sha1.Sum(data))\n    fmt.Printf("Sha256: %x\\n\\n", sha256.Sum256(data))\n    fmt.Printf("Sha512: %x\\n\\n", sha512.Sum512(data))\n}\n')),(0,a.kt)("p",null,"The example above copies the entire file in to memory. This was for convenience to pass it as a parameter to each of the hash functions. Another approach is to create the hash writer interface and write to it using Write(), WriteString(), or in this case, Copy(). The example below uses the md5 hash, but you can switch to use any of the others that are supported."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "crypto/md5"\n    "log"\n    "fmt"\n    "io"\n    "os"\n)\n\nfunc main() {\n    // Open file for reading\n    file, err := os.Open("test.txt")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n    \n    // Create new hasher, which is a writer interface\n    hasher := md5.New()\n    _, err = io.Copy(hasher, file)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Hash and print. Pass nil since\n    // the data is not coming in as a slice argument\n    // but is coming through the writer interface\n    sum := hasher.Sum(nil)\n    fmt.Printf("Md5 checksum: %x\\n", sum)\n}\n')),(0,a.kt)("h2",{id:"\u9644\u5f55golang-\u6587\u4ef6\u76f8\u5173\u51fd\u6570"},"\u9644\u5f55\uff1aGolang \u6587\u4ef6\u76f8\u5173\u51fd\u6570"),(0,a.kt)("h3",{id:"basic-operations"},"Basic Operations"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"create empty file"),(0,a.kt)("th",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"th"},'newFile, err := os.Cre\xadate\xad("te\xadst.t\xadxt\xad")')))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"truncate a file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := os.Tru\xadnca\xadte(\xad"\xadtes\xadt.t\xadxt", 100)'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"get file info"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'fileInfo, err := os.Sta\xadte(\xad"\xadtes\xadt.t\xadxt")'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"rename a file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"err := os.Ren\xadame\xad(ol\xaddPath, newPath)"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"delete a file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := os.Rem\xadove\xad("te\xadst.t\xadxt\xad")'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"open a file for reading"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'file, err := os.Ope\xadn("t\xadest.tx\xadt")'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"open a file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'file, err := os.Ope\xadn("t\xadest.tx\xadt", os.O_A\xadPPEND, 0600)'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"close a file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"err := file.C\xadlose()"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"change file permision"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := os.Chm\xadod(\xad"\xadtes\xadt.t\xadxt", 0777)'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"change file ownership"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := os.Cho\xadwn(\xad"\xadtes\xadt.t\xadxt", os.Get\xaduid(), os.Get\xadgid())'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"change file timestamps"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := os.Cht\xadime\xads("t\xadest.tx\xadt", lastAc\xadces\xadsTime, lastMo\xaddif\xadyTime)'))))),(0,a.kt)("h3",{id:"file-open-flag"},"file open flag"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"th"},"os.O_\xadRDONLY")),(0,a.kt)("th",{parentName:"tr",align:null},"open the file read only"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"os.O_\xadWRONLY")),(0,a.kt)("td",{parentName:"tr",align:null},"open the file write only")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"os.O_\xadRDWR")),(0,a.kt)("td",{parentName:"tr",align:null},"open the file read write")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"os.O_\xadAPPEND")),(0,a.kt)("td",{parentName:"tr",align:null},"append data to the file when writing")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"os.O_\xadCREATE")),(0,a.kt)("td",{parentName:"tr",align:null},"create a new file if none exists")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"os.O_\xadEXCL")),(0,a.kt)("td",{parentName:"tr",align:null},"used with ",(0,a.kt)("inlineCode",{parentName:"td"},"O_CRE\xadATE"),", file must not exist")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"os.O_\xadSYNC")),(0,a.kt)("td",{parentName:"tr",align:null},"open for synchr\xadonous I/O")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"O_TRUNC")),(0,a.kt)("td",{parentName:"tr",align:null},"if possible, truncate file when opened")))),(0,a.kt)("p",null,"When opening file with ",(0,a.kt)("inlineCode",{parentName:"p"},"os.Op\xadenF\xadile"),", flags control how the file behaves."),(0,a.kt)("h3",{id:"hard-link--symbol-link"},"Hard Link & Symbol Link"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"create a hard link"),(0,a.kt)("th",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"th"},'err := os.Lin\xadk("t\xadest.tx\xadt", "\xadtes\xadt_c\xadopy.tx\xadt")')))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"create a symbol link"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := os.Sym\xadlin\xadk("t\xadest.tx\xadt", "\xadtes\xadt_s\xadym.t\xadxt\xad")'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"get link file info"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'fileInfo, err := os.Lst\xadat(\xad"\xadtes\xadt_s\xadym.t\xadxt\xad")'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"change link file owner"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := os.Lch\xadown\xad("te\xadst_\xadsym.tx\xadt", uid, gid)'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"read a link"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'dest, err := os.Rea\xaddLi\xadnk(\xad"\xadlin\xadk_f\xadile.tx\xadt")'))))),(0,a.kt)("p",null,"A hard link creates a new pointer to the same place. A file will only be deleted from disk after all links are removed. Hard links only work on the same file system. A hard link is what you might consider a 'normal' link."),(0,a.kt)("p",null,"A symbolic link, or soft link, only reference other files by name. They can point to files on different filesy\xadstems. Not all systems support symlinks."),(0,a.kt)("h3",{id:"read-and-write"},"Read and Write"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"write bytes to file"),(0,a.kt)("th",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"th"},'n, err := file.W\xadrit\xade([\xad]by\xadte(\xad"\xadhello, world!\xad\\n"))')))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"write string to file, append string to file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'n, err := file.W\xadrit\xadeSt\xadrin\xadg("H\xadello, world!\xad\\n")'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"write at offset"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'n, err := file.W\xadrit\xadeAt\xad([]\xadbyt\xade("H\xadell\xado"), 10)'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"write from fmt"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'fmt.Fprint(file, "sdfs",1,2)'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"read to byte"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"n, err := file.R\xadead\xad(by\xadteS\xadlice)"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"read exactly n bytes"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"n, err := io.Rea\xaddFu\xadll(\xadfile, byteSl\xadice)"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"read at least n bytes"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"n, err := io.Rea\xaddAt\xadLea\xadst(\xadfile, byteSlice, minBytes)"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"read all bytes of a file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"byteS\xadlice, err := ioutil.Re\xadadA\xadll(\xadfile)"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"read from offset"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"n, err := file.R\xadead\xadAt(\xadbyt\xadeSlice, 10)"))))),(0,a.kt)("h3",{id:"work-with-directories"},"Work with direct\xadories"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"create a directory"),(0,a.kt)("th",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"th"},'err := os.Mkd\xadir(\xad"\xadmyD\xadir", 0600)')))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"recurs\xadively create a directory"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := os.Mkd\xadirA\xadll(\xad"\xaddir\xad/su\xadbdi\xadr/m\xadyDi\xadr", 0600)'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"delete a directory recurs\xadively"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := os.Rem\xadove\xadAll\xad("di\xadr/")'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"list directory files"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'fileInfo, err := ioutil.Re\xadadD\xadir(\xad".")'))))),(0,a.kt)("h3",{id:"shortcuts"},"Shortcuts"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"quick read from file"),(0,a.kt)("th",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"th"},'byteS\xadlice, err := ioutil.Re\xadadF\xadile\xad("te\xadst.t\xadxt\xad")')))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"quick write to file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'err := ioutil.Wr\xadite\xadFil\xade("t\xadest.tx\xadt", []byte\xad("He\xadllo\xad"), 0666)'))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"copy file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"n, err := io.Cop\xady(n\xadewFile, origin\xadFile)"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"write string to file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},'io.Wr\xadite\xadStr\xading\xad(file, "\xadHello, world")'))))),(0,a.kt)("h3",{id:"temporary-files-and-directories-1"},"Temporary files and direct\xadories"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"create temp dir"),(0,a.kt)("th",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"th"},"iouti\xadl.T\xademp\xadDir\xad(dir, prefix string) (name string, err error)")))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"create temp file"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"iouti\xadl.T\xademp\xadFil\xade(dir, prefix string) (f *os.File, err error)"))))),(0,a.kt)("h3",{id:"references"},"References"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"th",href:"http://devdungeon.com/content/working-files-go"},"Working with Files in Go")))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"https://golang.org/pkg/os/"},"golang ",(0,a.kt)("inlineCode",{parentName:"a"},"os")," standard library"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"https://golang.org/pkg/io/ioutil"},"golang ",(0,a.kt)("inlineCode",{parentName:"a"},"ioutil")," standard library"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"https://golang.org/pkg/io"},"golang ",(0,a.kt)("inlineCode",{parentName:"a"},"iou")," standard library"))))),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u6765\u81ea\uff1a",(0,a.kt)("a",{parentName:"p",href:"https://cheatography.com/cizixs/cheat-sheets/go-files/"},"https://cheatography.com/cizixs/cheat-sheets/go-files/"))),(0,a.kt)("h2",{id:"\u53c2\u8003\u94fe\u63a5"},"\u53c2\u8003\u94fe\u63a5"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Golang os package: ",(0,a.kt)("a",{parentName:"li",href:"https://pkg.go.dev/os"},"https://pkg.go.dev/os"))))}p.isMDXComponent=!0}}]);